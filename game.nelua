require 'config'
require 'riv'
require 'string'
require 'math'

local Piece = require 'piece'
local Board = require 'board'
local Timer = require 'timer'

local Game = @record {
  board: Board,
  cur_piece: Piece,
  next_piece: Piece,
  preview_piece: Piece,
  xmove_timer: Timer,
  ymove_timer: Timer,
  slide_vert_timer: Timer,
  score: integer,
  lines: integer,
  level: integer,
  hit_sound: riv_waveform_desc,
  lineclear_sound: riv_waveform_desc,
  levelup_sound: riv_waveform_desc
}

function Game:load_assets()
end

function Game:destroy_assets()
end

function Game:slide_piece_waydown(piece: *Piece)
  for y=1,VERT_CELLS do
    piece.y = piece.y + 1
    if self.board:piece_collides(piece) then
      break
    end
  end
  piece.y = piece.y - 1
end

function Game:update_preview_piece()
  self.preview_piece = self.cur_piece
  self:slide_piece_waydown(self.preview_piece)
end

function Game:spawn_piece()
  local piece = self.next_piece
  if self.board:piece_collides(piece) then
    return false
  end
  self.cur_piece = piece
  self.next_piece = Piece.random_piece()
  self:update_preview_piece()
  return true
end

function Game:new_game()
  self.board.cells = {}
  self.score = 0
  self.lines = 0
  self.level = 1
  self.slide_vert_timer:restart()
  self.xmove_timer:restart()
  self.ymove_timer:restart()
  self.next_piece = Piece.random_piece()
  self.cur_piece = Piece.random_piece()
  self:update_preview_piece()
end

function Game:clear_lines()
  local num_lines = self.board:clear_lines()
  local points = 0
  if num_lines == 4 then
    points = 1200
  elseif num_lines == 3 then
    points = 300
  elseif num_lines == 2 then
    points = 100
  elseif num_lines == 1 then
    points = 40
  end
  if points > 0 then
    -- PlaySound(self.lineclear_sound)
    self.lines = self.lines + num_lines
    local level = 1 + (self.lines // 10)
    if self.level ~= level then
      -- PlaySound(self.levelup_sound)
      self.level = level
    end
    self.score = self.score + points
  end
end

function Game:slide_current_piece(xoff: integer, yoff: integer)
  local piece = self.cur_piece
  piece:translate(xoff, yoff)
  if self.board:piece_collides(piece) then
    return false
  end
  self.cur_piece = piece
  self:update_preview_piece()
  return true
end

function Game:fit_piece(piece: *Piece): boolean
  if not self.board:piece_collides(piece) then
    return true
  end
  local newpiece = $piece
  for ix=1,2 do
    newpiece.x = piece.x + ix
    if not self.board:piece_collides(newpiece) then
      piece.x = newpiece.x
      return true
    end
    newpiece.x = piece.x - ix
    if not self.board:piece_collides(newpiece) then
      piece.x = newpiece.x
      return true
    end
  end
  newpiece = $piece
  for iy=1,3 do
    newpiece.y = piece.y - iy
    if not self.board:piece_collides(newpiece) then
      piece.y = newpiece.y
      return true
    end
  end
  return false
end

function Game:rotate_current_piece(left: boolean): boolean
  local piece = self.cur_piece
  if left then
    piece:rotate_left()
  else
    piece:rotate_right()
  end
  if not self:fit_piece(piece) then
    return false
  end
  self.cur_piece = piece
  self:update_preview_piece()
  return true
end

function Game:place_current_piece()
  -- PlaySound(self.hit_sound)
  self.board:place_piece(self.cur_piece)
  self:clear_lines()
  if not self:spawn_piece() then
    riv.quit = true
  end
end

function Game:update()
  local XMOVE_COOLDOWN = 0.08
  local YMOVE_COOLDOWN = 0.05
  local INTERVAL_DECAY = 0.03
  local slide_interval = 0.5 - (self.level - 1)*INTERVAL_DECAY

  -- check slide to the left/right
  local colided = false
  if self.xmove_timer:elapsed() >= XMOVE_COOLDOWN then
    if riv.keys[RIV_GAMEPAD_LEFT].down then
      self.xmove_timer:restart()
      self:slide_current_piece(-1, 0)
    elseif riv.keys[RIV_GAMEPAD_RIGHT].down then
      self.xmove_timer:restart()
      self:slide_current_piece(1, 0)
    end
  end
  if self.ymove_timer:elapsed() >= YMOVE_COOLDOWN then
    if riv.keys[RIV_GAMEPAD_DOWN].down then
      self.ymove_timer:restart()
      self.slide_vert_timer:restart()
      if not self:slide_current_piece(0, 1) then
        self:place_current_piece()
      end
    end
  end

  if riv.keys[RIV_GAMEPAD_UP].press then
    self:rotate_current_piece(false)
  elseif riv.keys[RIV_GAMEPAD_A1].press then
    self:rotate_current_piece(true)
  elseif riv.keys[RIV_GAMEPAD_A2].press then
    self.slide_vert_timer:restart()
    self:slide_piece_waydown(self.cur_piece)
    self:place_current_piece()
  end

  -- slide down automatically
  if self.slide_vert_timer:elapsed() >= slide_interval then
    self.slide_vert_timer:restart()
    if not self:slide_current_piece(0, 1) then
      self:place_current_piece()
    end
  end

  -- save score
  local finished_str: string = riv.quit and 'true' or 'false'
  riv.outcard_len = riv_snprintf(&riv.outcard[0], RIV_SIZE_OUTCARD,
    [[JSON{"score":%d,"level":%d,"lines":%d,"frames":%u,"finished":%s}]],
      self.score, self.level, self.lines, riv.frame, finished_str)
end

local function draw_centered_text(text: string, rect: riv_recti, fontsize: integer, fgcolor: Color)
  if #text == 0 then return end
  riv_draw_text(text, RIV_SPRITESHEET_FONT_5X7, RIV_CENTER, rect.x + rect.width//2, rect.y + rect.height//2, fontsize, fgcolor)
end

local function draw_titled_number(title: string, num: integer, rect: riv_recti)
  local text <close> = tostring(num)
  riv_draw_rect_fill(rect.x, rect.y, rect.width, rect.height, RIV_COLOR_DARKSLATE)
  riv_draw_rect_line(rect.x, rect.y, rect.width, rect.height, RIV_COLOR_SLATE)
  draw_centered_text(text, rect, 1, RIV_COLOR_WHITE)
  local titlerect: riv_recti = rect
  titlerect.y = titlerect.y - 16
  draw_centered_text(title, titlerect, 1, RIV_COLOR_GOLD)
end

function Game:draw_score()
  draw_titled_number('Score', self.score, {8, 16, 86, 16})
  draw_titled_number('Level', self.level, {8, 48, 86, 16})
  draw_titled_number('Lines', self.lines, {8, 80, 86, 16})
end

function Game:draw_next_piece()
  local rect: riv_recti = {8, 112, 86, 48}
  local titlerect: riv_recti = rect
  titlerect.y = titlerect.y - 32
  riv_draw_rect_fill(rect.x, rect.y, rect.width, rect.height, RIV_COLOR_DARKSLATE)
  riv_draw_rect_line(rect.x, rect.y, rect.width, rect.height, RIV_COLOR_SLATE)
  draw_centered_text('Next', titlerect, 1, RIV_COLOR_GOLD)
  local x = rect.x + (rect.width - self.next_piece.width*CELL_SIZE) // 2
  local y = rect.y + (rect.height - self.next_piece.height*CELL_SIZE) // 2
  self.next_piece:draw(x, y, false)
end

function Game:draw_piece()
  self.board:draw_piece(self.cur_piece, false)
  self.board:draw_piece(self.preview_piece, true)
end

function Game:draw()
  riv_clear(RIV_COLOR_DARKSLATE)
  self:draw_score()
  self.board:draw()
  self:draw_next_piece()
  self:draw_piece()
end

return Game
